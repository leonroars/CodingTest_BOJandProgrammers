import java.io.IOException;
import java.io.InputStreamReader;
import java.io.BufferedReader;
import java.util.StringTokenizer;

// 풀이 및 접근
// 드디어 처음부터 끝까지 내 힘으로 풀어낸 동적계획법 문제이다.
//
// I. 입력을 어떻게 표현하고 저장할 것인가? 
// 가장 먼저 고민한 것은 집 번호와 해당 집을 칠할 때 각 색깔 별 비용을 함께 묶어 표현 및 저장하는 방법이었다.
// 모든 집이 공통적으로 '각 색깔 별로 칠하는 비용'이라는 속성을 공유하고 있는 점에 착안하여,
// 집을 행(데이터베이스 스키마에서의 엔티티), 색깔 별로 칠하는 비용을 열(데이터베이스 스키아에서의 애트리뷰트)로
// 표현하는 것이 적절하다고 생각했다.
// 따라서 받은 입력을 2차원 배열 cost로 표현하였다.
// 이때 cost[i][0] 은 i번째 집을 R로 칠할 때의 비용,
// cost[i][1]은 G로 칠할 때의 비용 마지막으로 cost[i][2]는 B로 칠할 때의 비용을 의미한다.
//
// II. 문제 탐색 방안 모색하기 
// 그렇다면 각 집을 규칙대로 칠할 때의 최소 비용을 어떻게 구할 것인가? 마찬가지로 다음 질문 두 가지를 스스로 생각해보았다.
//  1. 최소값을 보장하는 탐색 방식이 있는가? ex. 다익스트라 알고리즘
//     만약 어떤 색을 칠하는 행위를 무색 - 색깔 상태간 이동, 해당 집의 색깔별 색칠 비용을 간선 가중치로 생각해볼 수도 있다.
//     하지만 동적 계획법을 연습하기 위해 이 문제를 풀고있었으므로, 해당 풀이는 더 고민해보지 않았다.
//     혹은 그리디 알고리즘적 접근처럼 특정 선택이 전체 최소값으로 귀결되는지에 관한 고민도 해보았으나,
//     이 문제는 그렇지 않았다. 지금 당장 최소 비용인 색깔을 고르더라도, 그 다음 가능한 선택이 모두 가장 비싼 금액을 요구한다면
//     전체 최소값을 갖는 시나리오가 아니게 되기 때문이다. 즉, 부분 최적해가 전체 최적해로 귀결되지 않는다.
//  2. 완전탐색이 가능한가?
//     완전탐색은 다음과 같은 순서로 이루어질 것이다.
//     1) 1번째 집을 세가지 중 하나의 색으로 칠한다.
//     2) 다음 집을 규칙에 맞는 색으로 칠한다. 이때 규칙 상 가능한 색은 앞에 칠한 색을 제외한 두 가지 색이다.
//     3) 위의 과정을 N번째 집까지 반복한 후 해당 시나리오의 색칠 비용을 산출한다.
//     가능한 선택지를 그림으로 그려보면 이진트리의 형태로,
//     하나의 집을 칠할 때마다 가능한 다음 집의 색이 두 가지씩 존재함을 알 수 있다.
//     첫 집의 색을 선택할 수 있는 가능성이 3가지가 있고 각 선택 별로 2^n-1 가지의 선택지가 존재하는 것이므로,
//     탐색해야하는 경우의 수는 모두 3*2^N-1가지가 된다.
//     입력 상한인 1,000을 대입해 개략적으로 가늠해보아도 문제의 제한시간 내에 절대 해결할 수 없음을 알 수 있다.
// 
// 최소값을 보장하는 탐색 방식의 존재 유무에 대한 고려는 배제했고, 완전탐색은 불가능한 상황이다.
// 그렇다면 다음으로 고민해보아야할 것은 '부분문제가 존재하는가?'와 '중복되는 부분문제가 존재하는가'이다.
// 이 문제에서 부분 문제는 '규칙을 깨지 않으면서 지금까지의 비용이 최소가 유지되도록 지금 집의 색을 정하는 것'이다.
// 언뜻 생각해보면 모든 가능성을 고려해야하는 것처럼 보이지만, 첫 번째 집의 색깔 세 가지로 시작해 그 다음 번 집의 가능한 색깔을
// 나열해보면 위에서 언급했던 '이진트리' 형태로 가능한 모든 선택지를 나열해볼 수 있음을 알 수 있다.
//
//  1   2   3   4
//  R - G - R - G
//   |        - B
//   |    - B - R
//   |        - G
//   |- B - R - B
//            - G
//        - G - R
//            - B
//  1   2   3
//  G - R - B
//        - G
//    - B - R
//        - G
//
// 부분문제들을 이렇게 트리로 구조화하고 살펴보면 중복되는 부분문제가 존재함을 알 수 있다. (물론 비둘기집의 원리로 생각해보아도 알 수 있다.)
// 첫 번째 집을 어떤 색으로 칠하기로 정하던, 반드시 다른 두 색을 칠했을 때 가능한 경우의 수와 겹치는 부분이 있다.
// 위의 도식을 살펴보면
// 첫 번째 집을 R로 칠하는 경우와 G로 칠하는 경우 모두, 2번째 집의 색을 B로 칠하는 경우의 수를 포함한다는 것을 알 수 있다.
// 바로 이 부분이 '중복되는 부분문제'이다.
// 바로 이 중복되는 부분문제의 해답을 저장함으로써 동적 계획법의 효율성을 활용할 수 있을 것이다.
// 무엇을 어떻게 저장할 것인가에 대한 대답을 할 수 있다면 동적 계획법의 풀이를 찾은 것이나 다름이 없어 보였다.
// 우선 '어떤 집'과 '어떤 색'이 상태를 정의하므로, 메모이제이션을 위한 배열은 이차원이 되어야할 것이라고 생각했다.
// 이에 메모이제이션을 위한 배열을 dp[houseNumber][colorCost]와 같은 형태로 표현해보았다.
// 그렇다면 거기에 무엇을 저장할 지 고민해보았을 때, 이전의 연속합 문제를 실패하고 배웠던 아이디어를 활용해보기로 했다.
// 'k번째 집을 칠하는 최소 비용은 1~k-1번째 집까지 칠하는 비용에 지금 가능한 비용을 더한 것이다.'라는 아이디어이다.
// 즉, '현재 최소 부분합은 이전 최소 부분합을 포함한다'는 아이디어이다.
// 이를 활용해보면 dp[i][R]는,
// 'i번째 집을 R로 칠할 때의 최소 누적비용'이다.
// 이를 알기 위해선 dp[i-1][G] 와 dp[i-1][B]중 작은 것과 cost[i][R]을 더하면 알 수 있을 것이다.
// 이를 점화식의 형태로 일반화 해보면
// 집의 번호를 i라고 할 때,
// 1) i == 0 / 첫 번째 집인 경우
//    dp[0][j] == cost[0][j]
// 2) i > 0 // 두 번째 집 부터는,
//    int current; // i번째 집까지 칠했을 때의 최소 누적 비용
//    if(j == 0) // i번째 집을 R로 칠하는 경우. 그렇다면 앞의 집은 G 혹은 B일 것이다.
//       // (i-1번째 집을 G로 칠했을 때의 최소누적비용 + i를 R로 칠하는 비용)과 다른 경우 중 작은 값 선택.
//       current = min(dp[i-1][1] + cost[i][j], dp[i-1][2] + cost[i][j])
//     ...
//
// 이를 첫 번째 집부터 N번째 집을 방문하며 시행한다면 원하는 최소 누적 비용을 선형 시간에 계산할 수 있게 된다.

public class Main {
   static int[][] cost; // i번째 집을 R, G, B로 칠하는 비용을 담은 이차원 배열
   static int[][] dp; // i번째 집을 R로 칠할 때 가능한 최소 누적 비용
   static int N; // The number of houses.
   
   static void addHouse(String colorCost, int houseNum) {
      StringTokenizer st = new StringTokenizer(colorCost);
      for(int i = 0; i < 3; i++) {
         // 0 - R; 1 - G; 2 - B
         int currentCost = Integer.parseInt(st.nextToken());
         cost[houseNum][i] = currentCost;
      }
   }
   
   static int minCost() {
      for(int i = 0; i < N; i++) {
         for(int j = 0; j < 3; j++) {
            if(i == 0) {
               dp[0][j] = cost[0][j];
            } else {
               // 현재 집을 칠하는 비용 + 현재 집을 해당 색깔로 칠할 수 있도록 하는 i-1번째 집의 색 별 누적 최소비용 중 더 작은 것.
               int current;
                // 현재 집을 R로 칠하는 경우, 바로 앞의 집이 G 혹은 B일 때의 최소 비용 중 작은 것이 최소합 시나리오일 것이다.
               if(j == 0) {current = Math.min(dp[i-1][1] + cost[i][j], dp[i-1][2] + cost[i][j]);}
                // 현재 집을 G로 칠하는 경우
               else if(j == 1) {current = Math.min(dp[i-1][0] + cost[i][j], dp[i-1][2] + cost[i][j]);}
                // 현재 집을 B로 칠하는 경우
               else {current = Math.min(dp[i-1][0] + cost[i][j], dp[i-1][1] + cost[i][j]);}
               // 만약 현재까지의 누적합보다 더 작은 값이 존재하거나, 아직 최초 누적합 계산이 안된 경우 갱신.
               if(dp[i][j] == 0 || dp[i][j] > current) {dp[i][j] = current;}
            }
         }
      }
      int smallest = Integer.MAX_VALUE;
      for(int k = 0; k < 3; k++) {
         if(dp[N-1][k] < smallest) {smallest = dp[N-1][k];}
      }
      
      return smallest;
   }
   
    public static void main(String[] args) throws IOException {
       BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
       N = Integer.parseInt(br.readLine());
       cost = new int[N][3];
       dp = new int[N][3];
       
       for(int i = 0; i < N; i++) {
          String costs = br.readLine();
          addHouse(costs, i);
       }
       
       System.out.print(minCost());
    }
}